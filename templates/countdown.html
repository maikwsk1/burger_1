<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <title>æ–™ç†ã‚²ãƒ¼ãƒ ï¼ˆã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ï¼‹ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ï¼‰</title>
    <!-- å¤–éƒ¨ CSS ã®èª­ã¿è¾¼ã¿ -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
    <h1>æ–™ç†ã‚²ãƒ¼ãƒ ï¼ˆã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ï¼‹ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ï¼‰</h1>

    <div id="timer">120</div>
    <div id="controlBtns">
        <button id="startBtn">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        <button id="pauseBtn">ä¸€æ™‚åœæ­¢</button>
        <button id="resumeBtn">å†ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
    </div>
    <p><a href="/">â† ãƒ›ãƒ¼ãƒ ã¸æˆ»ã‚‹</a></p>
    <div id="score">ã‚¹ã‚³ã‚¢: 0</div>
    <div id="orderContainer"></div>
    <div class="grid" id="grid"></div>
    <script>
        (() => {
            const baseItems = [
                { x: 0, y: 0, emoji: "ğŸ¥©", type: "fridge" },
                { x: 2, y: 0, emoji: "ğŸ¥¬", type: "fridge" },
                { x: 3, y: 0, emoji: "ğŸ…", type: "fridge" },
                { x: 4, y: 0, emoji: "ğŸ«“", type: "fridge" },
                { x: 4, y: 2, emoji: "ğŸ”ª", type: "fixed", name: "åŒ…ä¸" },
                { x: 5, y: 2, emoji: "ğŸ”¥", type: "fixed", name: "ç«" },
                { x: 6, y: 0, emoji: "ğŸ½ï¸", type: "fixed", name: "æä¾›å ´æ‰€" },
                { x: 8, y: 4, emoji: "ğŸ§¾", type: "serve" }
            ];
            const BURGER_RECIPES = {
                "ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼": ["ğŸ«“", "ğŸ¥©:cooked", "ğŸ¥¬:cut"],
                "ãƒ™ã‚¸ãƒãƒ¼ã‚¬ãƒ¼": ["ğŸ«“", "ğŸ¥¬:cut", "ğŸ…:cut"],
                "ãƒŸãƒ¼ãƒˆã‚µãƒ³ãƒ‰": ["ğŸ«“", "ğŸ¥©:cooked"]
            };

            let spawnedItems = [], px = 1, py = 1, holding = null;
            let timer = 120, playing = false, countdownInterval = null, orderInterval = null, orderUpdateInterval = null;
            let pausedTime = null;
            let activeOrders = []; // { name, items, remain, div }
            let score = 0;

            const grid = document.getElementById("grid"),
                timerEl = document.getElementById("timer"),
                orderEl = document.getElementById("orderContainer"),
                scoreEl = document.getElementById("score"),
                startBtn = document.getElementById("startBtn"),
                pauseBtn = document.getElementById("pauseBtn"),
                resumeBtn = document.getElementById("resumeBtn");

            function genId() { return 's-' + Math.random().toString(36).slice(2, 9); }
            function findCell(x, y) { return [...grid.children].find(c => +c.dataset.x === x && +c.dataset.y === y); }
            function isProcessed(it) { return (it.checked || it.cooked) && ["ğŸ¥©", "ğŸ¥¬", "ğŸ…"].includes(it.emoji); }

            function combineToBurger(x, y) {
                const plate = baseItems.find(b => b.x === x && b.y === y && b.emoji === "ğŸ½ï¸");
                if (!plate) return;
                const cellItems = spawnedItems.filter(it => it.x === x && it.y === y && !it.isBurger);
                const bread = cellItems.filter(it => it.emoji === "ğŸ«“").length;
                const processed = cellItems.filter(isProcessed);
                if (bread > 0 && processed.length > 0) {
                    let burger = spawnedItems.find(it => it.x === x && it.y === y && it.isBurger);
                    if (!burger) {
                        burger = { x, y, emoji: "ğŸ”", id: genId(), isBurger: true, contents: [] };
                        spawnedItems.push(burger);
                    }
                    processed.forEach(it => {
                        if (!burger.contents.includes(it.emoji)) burger.contents.push(it.emoji);
                        spawnedItems = spawnedItems.filter(s => s.id !== it.id);
                    });
                    spawnedItems = spawnedItems.filter(s => !(s.x === x && s.y === y && s.emoji === "ğŸ«“"));
                }
            }

            function renderGrid() {
                grid.innerHTML = "";
                for (let y = 0; y < 5; y++) for (let x = 0; x < 9; x++) {
                    const cell = document.createElement("div");
                    cell.className = "cell"; cell.dataset.x = x; cell.dataset.y = y; grid.appendChild(cell);
                }
                baseItems.forEach(it => {
                    const cell = findCell(it.x, it.y);
                    if (cell) {
                        const e = document.createElement("div"); e.className = "emoji"; e.textContent = it.emoji;
                        if (it.name) e.title = it.name;
                        cell.appendChild(e);
                    }
                });
                spawnedItems.forEach(it => { if (!it.isBurger) combineToBurger(it.x, it.y); });
                spawnedItems.forEach(it => {
                    const cell = findCell(it.x, it.y);
                    if (cell) {
                        const e = document.createElement("div"); e.className = "emoji"; e.textContent = it.emoji;
                        if (it.checked) e.classList.add("checked");
                        if (it.cooked && it.emoji === "ğŸ¥©") e.classList.add("cooked");
                        cell.appendChild(e);
                        if (it.isBurger && it.contents.length > 0) {
                            const tip = document.createElement("div"); tip.className = "burger-tooltip"; tip.textContent = it.contents.join(",");
                            cell.appendChild(tip);
                        }
                    }
                });
                const playerEl = document.createElement("div"); playerEl.className = "player";
                const cell = findCell(px, py); if (cell) cell.appendChild(playerEl);
                if (holding) {
                    const held = document.createElement("div"); held.className = "emoji"; held.textContent = holding.emoji;
                    if (holding.checked) held.classList.add("checked");
                    if (holding.cooked && holding.emoji === "ğŸ¥©") held.classList.add("cooked");
                    held.style.zIndex = 60; cell.appendChild(held);
                    if (holding.isBurger && holding.contents.length > 0) {
                        const tip = document.createElement("div"); tip.className = "burger-tooltip"; tip.textContent = holding.contents.join(",");
                        cell.appendChild(tip);
                    }
                }
            }

            function handleDAction() {
                if (!playing) return;
                console.log("handleDAction å‘¼ã°ã‚ŒãŸ: px=", px, "py=", py, "holding=", holding);

                if (!holding) {
                    // æ‹¾ã†å‡¦ç†
                    const idx = spawnedItems.findIndex(it => it.x === px && it.y === py);
                    if (idx >= 0) {
                        holding = spawnedItems.splice(idx, 1)[0];
                        renderGrid();
                        return;
                    }
                    const fridgeHere = baseItems.find(f => f.type === "fridge" && f.x === px && f.y === py);
                    if (fridgeHere) {
                        holding = { emoji: fridgeHere.emoji, id: genId(), checked: false, cooked: false };
                        renderGrid();
                        return;
                    }
                } else {
                    // ãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ã‚’æä¾›ï¼ˆğŸ§¾ã‚¹ãƒšãƒ¼ã‚¹ï¼‰
                    const serveHere = baseItems.find(f => f.type === "serve" && f.x === px && f.y === py);
                    if (holding.isBurger && serveHere) {
                        console.log("æä¾›ä¸­ holding:", holding.contents);

                        let matched = false;
                        for (let i = 0; i < activeOrders.length; i++) { // å…ˆã«å‡ºãŸæ³¨æ–‡ã‚’å„ªå…ˆ
                            const order = activeOrders[i];
                            const orderContents = order.items
                                .split(" + ")
                                .map(it => it.replace(/:cooked|:cut/g, ""))
                                .filter(it => it !== "ğŸ«“"); // ãƒ‘ãƒ³ã¯é™¤å¤–
                            const holdingContents = holding.contents.slice().sort();

                            if (holdingContents.join() === orderContents.join()) {
                                // æˆåŠŸ: ã‚¹ã‚³ã‚¢åŠ ç®—
                                score += 100;
                                scoreEl.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;

                                // æ³¨æ–‡ã‚’ç”»é¢ã‹ã‚‰æ¶ˆã™
                                order.div.remove();
                                activeOrders.splice(i, 1);
                                matched = true;
                                break; // æœ€åˆã«ãƒãƒƒãƒã—ãŸæ³¨æ–‡ã ã‘å‡¦ç†
                            }
                        }

                        if (!matched) {
                            // æ³¨æ–‡ã«ãªã„æ–™ç†ã‚’æä¾› â†’ å¤±æ•—
                            score -= 30;
                            scoreEl.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
                        }

                        // æä¾›ã—ãŸãƒãƒ³ãƒãƒ¼ã‚¬ãƒ¼ã¯å¿…ãšæ¶ˆã™
                        holding = null;
                        renderGrid();
                        return;
                    }

                    // é€šå¸¸ã®ç½®ãå‡¦ç†
                    spawnedItems.push({ ...holding, x: px, y: py });
                    holding = null;
                    renderGrid();
                    return;
                }
            }



            function handleWAction() {
                if (!playing) return;
                if (px === 4 && py === 2) { // åŒ…ä¸
                    spawnedItems.forEach(it => { if (it.x === px && it.y === py && ["ğŸ¥©", "ğŸ¥¬", "ğŸ…"].includes(it.emoji)) it.checked = true; });
                    if (holding && ["ğŸ¥©", "ğŸ¥¬", "ğŸ…"].includes(holding.emoji)) holding.checked = true;
                }
                if (px === 5 && py === 2) { // ç«
                    spawnedItems.forEach(it => { if (it.x === px && it.y === py && it.emoji === "ğŸ¥©" && it.checked) { it.cooked = true; it.checked = false; } });
                    if (holding && holding.emoji === "ğŸ¥©" && holding.checked) { holding.cooked = true; holding.checked = false; }
                }
                renderGrid();
            }

            document.addEventListener("keydown", e => {
                if (!playing) return;
                if (e.key.startsWith("Arrow")) e.preventDefault();
                if (e.key === "ArrowUp" && py > 0) py--;
                if (e.key === "ArrowDown" && py < 4) py++;
                if (e.key === "ArrowLeft" && px > 0) px--;
                if (e.key === "ArrowRight" && px < 8) px++;
                if (e.key === "d" || e.key === "D") handleDAction();
                if (e.key === "w" || e.key === "W") handleWAction();
                renderGrid();
            });

            function showRandomOrder() {
                if (!playing) return;
                if (activeOrders.length >= 7) return;
                const keys = Object.keys(BURGER_RECIPES);
                const name = keys[Math.floor(Math.random() * keys.length)];
                const items = BURGER_RECIPES[name].join(" + ");
                const div = document.createElement("div");
                div.className = "order";
                const remain = 25;
                div.textContent = `æ³¨æ–‡: ${name} â†’ ${items} ï¼ˆæ®‹ã‚Š${remain}ç§’ï¼‰`;
                orderEl.appendChild(div);
                activeOrders.push({ name, items, remain, div });
            }

            function updateOrders() {
                if (!playing) return;
                for (let i = activeOrders.length - 1; i >= 0; i--) {
                    const order = activeOrders[i];
                    order.remain--;
                    if (order.remain > 0) {
                        order.div.textContent = `æ³¨æ–‡: ${order.name} â†’ ${order.items} ï¼ˆæ®‹ã‚Š${order.remain}ç§’ï¼‰`;
                    } else {
                        // æ™‚é–“åˆ‡ã‚Œ â†’ -30ç‚¹
                        score -= 30;
                        scoreEl.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
                        order.div.remove();
                        activeOrders.splice(i, 1);
                    }
                }
            }

            function startCountdown(reset = true) {
                if (reset) { timer = 120; score = 0; scoreEl.textContent = `ã‚¹ã‚³ã‚¢: ${score}`; }
                playing = true;
                timerEl.textContent = timer;
                clearInterval(countdownInterval); clearInterval(orderInterval); clearInterval(orderUpdateInterval);

                countdownInterval = setInterval(() => {
                    timer--;
                    timerEl.textContent = timer;
                    if (timer <= 0) {
                        clearInterval(countdownInterval); clearInterval(orderInterval); clearInterval(orderUpdateInterval);
                        playing = false;
                        timerEl.textContent = "çµ‚äº†";
                        startBtn.style.display = "inline";
                    }
                }, 1000);

                if (reset) showRandomOrder();
                orderInterval = setInterval(showRandomOrder, 15000);
                orderUpdateInterval = setInterval(updateOrders, 1000);
            }

            startBtn.onclick = () => { startCountdown(true); startBtn.style.display = "none"; };
            pauseBtn.onclick = () => { clearInterval(countdownInterval); clearInterval(orderInterval); clearInterval(orderUpdateInterval); playing = false; pausedTime = timer; };
            resumeBtn.onclick = () => { if (pausedTime && !playing) { timer = pausedTime; startCountdown(false); pausedTime = null; } };

            renderGrid();
        })();
    </script>
</body>

</html>