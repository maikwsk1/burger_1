<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="utf-8" />
    <title>料理ゲーム（カウントダウン＋ハンバーガー）</title>
    <!-- 外部 CSS の読み込み -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
    <h1>料理ゲーム（カウントダウン＋ハンバーガー）</h1>

    <div id="timer">120</div>
    <div id="controlBtns">
        <button id="startBtn">スタート</button>
        <button id="pauseBtn">一時停止</button>
        <button id="resumeBtn">再スタート</button>
    </div>
    <p><a href="/">← ホームへ戻る</a></p>
    <div id="score">スコア: 0</div>
    <div id="orderContainer"></div>
    <div class="grid" id="grid"></div>
    <script>
        (() => {
            const baseItems = [
                { x: 0, y: 0, emoji: "🥩", type: "fridge" },
                { x: 2, y: 0, emoji: "🥬", type: "fridge" },
                { x: 3, y: 0, emoji: "🍅", type: "fridge" },
                { x: 4, y: 0, emoji: "🫓", type: "fridge" },
                { x: 4, y: 2, emoji: "🔪", type: "fixed", name: "包丁" },
                { x: 5, y: 2, emoji: "🔥", type: "fixed", name: "火" },
                { x: 6, y: 0, emoji: "🍽️", type: "fixed", name: "提供場所" },
                { x: 8, y: 4, emoji: "🧾", type: "serve" }
            ];
            const BURGER_RECIPES = {
                "ハンバーガー": ["🫓", "🥩:cooked", "🥬:cut"],
                "ベジバーガー": ["🫓", "🥬:cut", "🍅:cut"],
                "ミートサンド": ["🫓", "🥩:cooked"]
            };

            let spawnedItems = [], px = 1, py = 1, holding = null;
            let timer = 120, playing = false, countdownInterval = null, orderInterval = null, orderUpdateInterval = null;
            let pausedTime = null;
            let activeOrders = []; // { name, items, remain, div }
            let score = 0;

            const grid = document.getElementById("grid"),
                timerEl = document.getElementById("timer"),
                orderEl = document.getElementById("orderContainer"),
                scoreEl = document.getElementById("score"),
                startBtn = document.getElementById("startBtn"),
                pauseBtn = document.getElementById("pauseBtn"),
                resumeBtn = document.getElementById("resumeBtn");

            function genId() { return 's-' + Math.random().toString(36).slice(2, 9); }
            function findCell(x, y) { return [...grid.children].find(c => +c.dataset.x === x && +c.dataset.y === y); }
            function isProcessed(it) { return (it.checked || it.cooked) && ["🥩", "🥬", "🍅"].includes(it.emoji); }

            function combineToBurger(x, y) {
                const plate = baseItems.find(b => b.x === x && b.y === y && b.emoji === "🍽️");
                if (!plate) return;
                const cellItems = spawnedItems.filter(it => it.x === x && it.y === y && !it.isBurger);
                const bread = cellItems.filter(it => it.emoji === "🫓").length;
                const processed = cellItems.filter(isProcessed);
                if (bread > 0 && processed.length > 0) {
                    let burger = spawnedItems.find(it => it.x === x && it.y === y && it.isBurger);
                    if (!burger) {
                        burger = { x, y, emoji: "🍔", id: genId(), isBurger: true, contents: [] };
                        spawnedItems.push(burger);
                    }
                    processed.forEach(it => {
                        if (!burger.contents.includes(it.emoji)) burger.contents.push(it.emoji);
                        spawnedItems = spawnedItems.filter(s => s.id !== it.id);
                    });
                    spawnedItems = spawnedItems.filter(s => !(s.x === x && s.y === y && s.emoji === "🫓"));
                }
            }

            function renderGrid() {
                grid.innerHTML = "";
                for (let y = 0; y < 5; y++) for (let x = 0; x < 9; x++) {
                    const cell = document.createElement("div");
                    cell.className = "cell"; cell.dataset.x = x; cell.dataset.y = y; grid.appendChild(cell);
                }
                baseItems.forEach(it => {
                    const cell = findCell(it.x, it.y);
                    if (cell) {
                        const e = document.createElement("div"); e.className = "emoji"; e.textContent = it.emoji;
                        if (it.name) e.title = it.name;
                        cell.appendChild(e);
                    }
                });
                spawnedItems.forEach(it => { if (!it.isBurger) combineToBurger(it.x, it.y); });
                spawnedItems.forEach(it => {
                    const cell = findCell(it.x, it.y);
                    if (cell) {
                        const e = document.createElement("div"); e.className = "emoji"; e.textContent = it.emoji;
                        if (it.checked) e.classList.add("checked");
                        if (it.cooked && it.emoji === "🥩") e.classList.add("cooked");
                        cell.appendChild(e);
                        if (it.isBurger && it.contents.length > 0) {
                            const tip = document.createElement("div"); tip.className = "burger-tooltip"; tip.textContent = it.contents.join(",");
                            cell.appendChild(tip);
                        }
                    }
                });
                const playerEl = document.createElement("div"); playerEl.className = "player";
                const cell = findCell(px, py); if (cell) cell.appendChild(playerEl);
                if (holding) {
                    const held = document.createElement("div"); held.className = "emoji"; held.textContent = holding.emoji;
                    if (holding.checked) held.classList.add("checked");
                    if (holding.cooked && holding.emoji === "🥩") held.classList.add("cooked");
                    held.style.zIndex = 60; cell.appendChild(held);
                    if (holding.isBurger && holding.contents.length > 0) {
                        const tip = document.createElement("div"); tip.className = "burger-tooltip"; tip.textContent = holding.contents.join(",");
                        cell.appendChild(tip);
                    }
                }
            }

            function handleDAction() {
                if (!playing) return;
                console.log("handleDAction 呼ばれた: px=", px, "py=", py, "holding=", holding);

                if (!holding) {
                    // 拾う処理
                    const idx = spawnedItems.findIndex(it => it.x === px && it.y === py);
                    if (idx >= 0) {
                        holding = spawnedItems.splice(idx, 1)[0];
                        renderGrid();
                        return;
                    }
                    const fridgeHere = baseItems.find(f => f.type === "fridge" && f.x === px && f.y === py);
                    if (fridgeHere) {
                        holding = { emoji: fridgeHere.emoji, id: genId(), checked: false, cooked: false };
                        renderGrid();
                        return;
                    }
                } else {
                    // ハンバーガーを提供（🧾スペース）
                    const serveHere = baseItems.find(f => f.type === "serve" && f.x === px && f.y === py);
                    if (holding.isBurger && serveHere) {
                        console.log("提供中 holding:", holding.contents);

                        let matched = false;
                        for (let i = 0; i < activeOrders.length; i++) { // 先に出た注文を優先
                            const order = activeOrders[i];
                            const orderContents = order.items
                                .split(" + ")
                                .map(it => it.replace(/:cooked|:cut/g, ""))
                                .filter(it => it !== "🫓"); // パンは除外
                            const holdingContents = holding.contents.slice().sort();

                            if (holdingContents.join() === orderContents.join()) {
                                // 成功: スコア加算
                                score += 100;
                                scoreEl.textContent = `スコア: ${score}`;

                                // 注文を画面から消す
                                order.div.remove();
                                activeOrders.splice(i, 1);
                                matched = true;
                                break; // 最初にマッチした注文だけ処理
                            }
                        }

                        if (!matched) {
                            // 注文にない料理を提供 → 失敗
                            score -= 30;
                            scoreEl.textContent = `スコア: ${score}`;
                        }

                        // 提供したハンバーガーは必ず消す
                        holding = null;
                        renderGrid();
                        return;
                    }

                    // 通常の置く処理
                    spawnedItems.push({ ...holding, x: px, y: py });
                    holding = null;
                    renderGrid();
                    return;
                }
            }



            function handleWAction() {
                if (!playing) return;
                if (px === 4 && py === 2) { // 包丁
                    spawnedItems.forEach(it => { if (it.x === px && it.y === py && ["🥩", "🥬", "🍅"].includes(it.emoji)) it.checked = true; });
                    if (holding && ["🥩", "🥬", "🍅"].includes(holding.emoji)) holding.checked = true;
                }
                if (px === 5 && py === 2) { // 火
                    spawnedItems.forEach(it => { if (it.x === px && it.y === py && it.emoji === "🥩" && it.checked) { it.cooked = true; it.checked = false; } });
                    if (holding && holding.emoji === "🥩" && holding.checked) { holding.cooked = true; holding.checked = false; }
                }
                renderGrid();
            }

            document.addEventListener("keydown", e => {
                if (!playing) return;
                if (e.key.startsWith("Arrow")) e.preventDefault();
                if (e.key === "ArrowUp" && py > 0) py--;
                if (e.key === "ArrowDown" && py < 4) py++;
                if (e.key === "ArrowLeft" && px > 0) px--;
                if (e.key === "ArrowRight" && px < 8) px++;
                if (e.key === "d" || e.key === "D") handleDAction();
                if (e.key === "w" || e.key === "W") handleWAction();
                renderGrid();
            });

            function showRandomOrder() {
                if (!playing) return;
                if (activeOrders.length >= 7) return;
                const keys = Object.keys(BURGER_RECIPES);
                const name = keys[Math.floor(Math.random() * keys.length)];
                const items = BURGER_RECIPES[name].join(" + ");
                const div = document.createElement("div");
                div.className = "order";
                const remain = 25;
                div.textContent = `注文: ${name} → ${items} （残り${remain}秒）`;
                orderEl.appendChild(div);
                activeOrders.push({ name, items, remain, div });
            }

            function updateOrders() {
                if (!playing) return;
                for (let i = activeOrders.length - 1; i >= 0; i--) {
                    const order = activeOrders[i];
                    order.remain--;
                    if (order.remain > 0) {
                        order.div.textContent = `注文: ${order.name} → ${order.items} （残り${order.remain}秒）`;
                    } else {
                        // 時間切れ → -30点
                        score -= 30;
                        scoreEl.textContent = `スコア: ${score}`;
                        order.div.remove();
                        activeOrders.splice(i, 1);
                    }
                }
            }

            function startCountdown(reset = true) {
                if (reset) { timer = 120; score = 0; scoreEl.textContent = `スコア: ${score}`; }
                playing = true;
                timerEl.textContent = timer;
                clearInterval(countdownInterval); clearInterval(orderInterval); clearInterval(orderUpdateInterval);

                countdownInterval = setInterval(() => {
                    timer--;
                    timerEl.textContent = timer;
                    if (timer <= 0) {
                        clearInterval(countdownInterval); clearInterval(orderInterval); clearInterval(orderUpdateInterval);
                        playing = false;
                        timerEl.textContent = "終了";
                        startBtn.style.display = "inline";
                    }
                }, 1000);

                if (reset) showRandomOrder();
                orderInterval = setInterval(showRandomOrder, 15000);
                orderUpdateInterval = setInterval(updateOrders, 1000);
            }

            startBtn.onclick = () => { startCountdown(true); startBtn.style.display = "none"; };
            pauseBtn.onclick = () => { clearInterval(countdownInterval); clearInterval(orderInterval); clearInterval(orderUpdateInterval); playing = false; pausedTime = timer; };
            resumeBtn.onclick = () => { if (pausedTime && !playing) { timer = pausedTime; startCountdown(false); pausedTime = null; } };

            renderGrid();
        })();
    </script>
</body>

</html>